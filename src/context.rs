use tokio::runtime::Runtime;
use jsonwebtokens_cognito::{Error, KeySet};

async fn check_auth(jwt: &str) -> Result<AuthResult, Error> {
    let keyset = KeySet::new("us-west-2", "us-west-2_JIyd7gfYd")?;

    let verifier = keyset
        .new_id_token_verifier(&["76pmarb1rb17n3tctrdmsqv60e"])
        .build()?;

    let v = keyset.verify(jwt, &verifier).await;

    let authentication = v.is_ok();

    let unauth = AuthResult {
        auth: false,
        user_id: "USER_UNAUTH".to_string(),
    };

    if authentication {
        // Sub is the uuid generated by amazon cognito pool
        let res = match v.unwrap().get("cognito:username") {
            Some(x) => AuthResult {
                auth: authentication,
                user_id: x.as_str().unwrap().to_string(),
            },
            None => unauth,
        };
        return Ok(res);
    }
    Ok(unauth)
}

/**
 * Database context neccesary for rocket, wrap db connection inside of it or whatever you want.
 */

#[derive(Clone)]
pub struct Context {
}

/**
 * Auth Result struct to wrap the auth result with userid for authenteication and authorization
 */
pub struct AuthResult {
    pub auth: bool,
    pub user_id: String,
}

impl Context {
    pub fn new() -> Context {
        Context {}
    }
    pub fn authorize(self, jwt: String) -> AuthResult {
        let res = Runtime::new()
        .expect("Failed to create Tokio runtime")
        .block_on(check_auth(&jwt))
        .expect("Authorization Check Failed!");
         res
    }
}